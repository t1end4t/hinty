# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "chatgpt.baml": "// Define the conversation message structure\nclass ConversationMessage {\n  role \"user\" | \"assistant\"\n  content string\n}\n\n// Define available tools\nclass SearchWebTool {\n  tool_name \"search_web\"\n  query string @description(\"The search query to look up on the web\")\n}\n\nclass FetchUrlTool {\n  tool_name \"fetch_url\"\n  url string @description(\"The URL to fetch content from\")\n}\n\n// Response that includes both the answer and optional tool call\nclass ChatGPTOutput {\n  response string @description(\"Your helpful response to the user. If a tool is needed, explain what you're doing. If not, provide the complete answer.\")\n  tool_call SearchWebTool | FetchUrlTool | null @description(\"The tool to use if additional information is needed, or null if you can answer directly\")\n  requires_tool bool @description(\"True if a tool is needed to provide a complete answer, false if the response is complete\")\n}\n\n// Single function that returns response and determines tool usage\nfunction ChatGPT(\n  message: string,\n  conversation_history: ConversationMessage[]?,\n  tool_result: map<string, string>?\n) -> ChatGPTOutput {\n  client GroqRouter\n  prompt #\"\n    You are a helpful assistant that can use tools when needed.\n    \n    Available tools:\n    1. search_web - Search the internet for current information\n    2. fetch_url - Retrieve content from a specific URL\n    \n    {{ ctx.output_format }}\n    \n{% if conversation_history %}\n    CONVERSATION HISTORY:\n{% for msg in conversation_history -%}\n{{ msg.role | capitalize }}: {{ msg.content }}\n{% endfor %}\n{% endif %}\n\n{% if tool_result %}\nTOOL RESULT:\n    {{ tool_result }}\n    \n    Use the above tool result along with any provided file content to answer the question.\n{% endif %}\n    Current Question: {{ message }}\n    \n    Instructions:\n    - If you can answer the question directly with your knowledge or the provided file content, set requires_tool to false and provide a complete response\n    - If you need additional information (web search, URL fetch, RAG, or file write), set requires_tool to true, explain what you need to do, and specify the tool_call\n    - Always provide a response even if a tool is needed\n  \"#\n}\n\n// Function to generate final response after tool execution\ntest TestChatgpt1{\n    functions [ChatGPT]\n    args {\n        message \"Do you remember my name?\"\n        conversation_history [\n            {role: \"user\", content: \"Hi, I am Dat\"}\n            {role: \"assistant\", content: \"Hi Dat\"}\n        ]\n    }\n}\n\ntest TestChatgpt2{\n    functions [ChatGPT]\n    args {\n        message \"What is the capital of France?\"\n    }\n}\n",
    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\nclient<llm> GeminiGeneral {\n  provider \"openai-generic\"\n  retry_policy Exponential\n  options {\n    base_url \"https://openrouter.ai/api/v1\"\n    api_key env.OPENROUTER_API_KEY\n    model \"google/gemini-2.5-flash-lite-preview-09-2025\"\n  }\n}\n\nclient<llm> GroqRouter {\n  provider openai-generic\n  retry_policy Exponential\n  options {\n    base_url \"https://api.groq.com/openai/v1\"\n    api_key env.GROQ_API_KEY\n    model \"openai/gpt-oss-120b\"\n  }\n}\n\n\n// https://docs.boundaryml.com/docs/snippets/clients/retry\nretry_policy Constant {\n  max_retries 3\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}",
    "coder.baml": "class SearchReplaceBlock {\n  search string @description(\"Exact code to find - must match precisely including whitespace\")\n  replace string @description(\"Replacement code with same indentation\")\n  language string @description(\"Programming language for syntax highlighting\")\n}\n\nclass FileChange {\n  file_path string @description(\"Path to the file that needs modification\")\n  blocks SearchReplaceBlock[] @description(\"List of search/replace blocks to apply to this file\")\n  explanation string @description(\"Brief explanation of changes made to this file\")\n}\n\nclass CoderOutput {\n  thinking string @description(\"Your thought process - explain what you're doing and why, like talking to a colleague\")\n  files_to_change FileChange[] @description(\"List of files with their respective changes\")\n  additional_files_to_check string[] @description(\"Other files that might need updating based on these changes\")\n  summary string @description(\"Final wrap-up of what changed and why it solves the problem\")\n}\n\nclass FileInfo {\n  file_path string\n  file_content string\n}\n\nclass RelatedFile {\n  file_path string\n  relationship string @description(\"How it relates: imports_from, imported_by, uses, used_by, tests\")\n  relevant_excerpt string @description(\"Key functions/classes that matter\")\n}\n\nclass CodebaseContext {\n  file_tree string @description(\"Tree structure of the project\")\n  related_files RelatedFile[] @description(\"Files connected to the ones being edited\")\n  project_language string @description(\"Primary language: python, javascript, typescript, etc.\")\n  project_framework string? @description(\"Framework if applicable: React, Flask, Express, Django, etc.\")\n}\n\nfunction Coder(\n  user_message: string,\n  conversation_history: ConversationMessage[],\n  files: FileInfo[],\n  codebase_context: CodebaseContext?,\n) -> CoderOutput {\n  client GroqRouter\n  prompt #\"\nYou are an expert developer working on a codebase. Think and communicate like a human coder who understands the full context of the project.\n\n{% if codebase_context %}\nPROJECT OVERVIEW:\n{% if codebase_context.project_language %}\nLanguage: {{ codebase_context.project_language }}{% if codebase_context.project_framework %} | Framework: {{ codebase_context.project_framework }}{% endif %}\n{% endif %}\n\nPROJECT STRUCTURE:\n{{ codebase_context.file_tree }}\n\n{% if codebase_context.related_files|length > 0 %}\nRELATED FILES (dependencies and connections):\n{% for related in codebase_context.related_files %}\n{{ related.file_path }} ({{ related.relationship }})\n{{ related.relevant_excerpt }}\n\n{% endfor %}\n{% endif %}\n{% endif %}\n\nFILES I'M WORKING WITH:\n{% for file in files %}\n```\n{{ file.file_content }}\n```\n\n{% endfor %}\n\n{% if conversation_history|length > 0 %}\nCONTEXT FROM OUR CONVERSATION:\n{% for msg in conversation_history %}\n{{ msg.role }}: {{ msg.content }}\n{% endfor %}\n\n{% endif %}\nWHAT YOU NEED TO DO:\n{{ user_message }}\n\nHOW TO APPROACH THIS:\n\n1. THINKING SECTION - Reason through the problem like a developer would:\n   - Start with: \"Ok, looking at this request...\"\n{% if codebase_context %}\n   - Consider the project structure: \"I can see this is a {{ codebase_context.project_language if codebase_context }} project...\" \n{% endif %}\n   - Identify what needs changing: \"I need to modify [file] because...\"\n   - Think about related files: \"This might affect [other files] since...\"\n   - Plan your approach: \"The best way to handle this is...\"\n   \n   Be conversational and thorough. Show your reasoning process.\n\n2. MAKE YOUR CHANGES - For each file you identified:\n   - Create precise search/replace blocks\n   - CRITICAL: Search text must be EXACT matches from the original file (including all whitespace)\n   - Maintain the same indentation style (match spaces/tabs exactly)\n   - Make surgical, targeted changes - only touch what needs changing\n   - If you need to change multiple locations in a file, create separate blocks for each\n   - In the explanation field, describe what you changed and why\n\n3. FLAG RELATED FILES - Think about ripple effects:\n   - If you changed a function signature, what calls it?\n   - If you modified an import, what else imports from there?\n   - Are there tests that need updating?\n   - List these in additional_files_to_check\n\n4. SUMMARY - Wrap up naturally:\n   - \"So to recap, I've...\"\n   - List the key changes you made\n   - Explain why this solves the problem\n   - Mention any follow-up work needed\n\nTECHNICAL RULES FOR SEARCH/REPLACE:\n- Search blocks must match exactly (every space, tab, newline)\n- Each search block should be unique within its file\n- Preserve the existing code style and formatting\n- Don't search for partial lines - include full lines with proper indentation\n- If a line has leading spaces/tabs, include them in the search block\n\nCONTEXT AWARENESS:\n- Use the file tree to understand project organization\n- Check related files to avoid breaking dependencies\n- Match the project's language conventions and framework patterns\n- Consider imports and how files connect to each other\n\nThink of this like pair programming with someone who trusts your judgment. Be helpful, clear, and consider the broader impact of your changes.\n\n{{ ctx.output_format }}\n  \"#\n}\n\n\n// Test 1: Simple bug fix in a single file\ntest TestSimpleBugFix {\n  functions [Coder]\n  args {\n    user_message \"Fix the typo in the greeting message - it should say 'Hello' not 'Helo'\"\n    files [\n      {\n        file_path \"src/greeter.py\"\n        file_content #\"\ndef greet(name):\n    return f\"Helo, {name}!\"\n\ndef main():\n    print(greet(\"World\"))\n\"#\n      }\n    ]\n    codebase_context null\n    conversation_history []\n  }\n}\n\n// Test 2: Multi-file refactoring with context\ntest TestRefactorWithContext {\n  functions [Coder]\n  args {\n    user_message \"Rename the 'calculate_total' function to 'compute_sum' across all files\"\n    files [\n      {\n        file_path \"src/calculator.py\"\n        file_content #\"\ndef calculate_total(numbers):\n    return sum(numbers)\n\ndef get_average(numbers):\n    total = calculate_total(numbers)\n    return total / len(numbers)\n\"#\n      },\n      {\n        file_path \"src/main.py\"\n        file_content #\"\nfrom calculator import calculate_total\n\ndef process_data(data):\n    result = calculate_total(data)\n    print(f\"Total: {result}\")\n\"#\n      }\n    ]\n    codebase_context {\n      file_tree #\"\nsrc/\n├── calculator.py\n├── main.py\n└── test_calculator.py\n\"#\n      related_files [\n        {\n          file_path \"src/test_calculator.py\"\n          relationship \"tests\"\n          relevant_excerpt #\"\ndef test_calculate_total():\n    assert calculate_total([1, 2, 3]) == 6\n\"#\n        }\n      ]\n      project_language \"python\"\n      project_framework null\n    }\n    conversation_history []\n  }\n}\n\n// Test 3: Adding new functionality with framework context\ntest TestAddReactComponent {\n  functions [Coder]\n  args {\n    user_message \"Add a loading state to the UserProfile component that shows a spinner while data is being fetched\"\n    files [\n      {\n        file_path \"src/components/UserProfile.jsx\"\n        file_content #\"\nimport React from 'react';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = React.useState(null);\n\n  React.useEffect(() => {\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => setUser(data));\n  }, [userId]);\n\n  return (\n    <div className=\"profile\">\n      <h2>{user?.name}</h2>\n      <p>{user?.email}</p>\n    </div>\n  );\n}\n\nexport default UserProfile;\n\"#\n      }\n    ]\n    codebase_context {\n      file_tree #\"\nsrc/\n├── components/\n│   ├── UserProfile.jsx\n│   └── Spinner.jsx\n├── utils/\n│   └── api.js\n└── App.jsx\n\"#\n      related_files [\n        {\n          file_path \"src/components/Spinner.jsx\"\n          relationship \"used_by\"\n          relevant_excerpt #\"\nexport function Spinner() {\n  return <div className=\"spinner\">Loading...</div>;\n}\n\"#\n        }\n      ]\n      project_language \"javascript\"\n      project_framework \"React\"\n    }\n    conversation_history []\n  }\n}\n\n// Test 4: Multiple changes in same file\ntest TestMultipleChangesInFile {\n  functions [Coder]\n  args {\n    user_message \"Update all print statements to use logging instead, and add proper error handling\"\n    files [\n      {\n        file_path \"src/processor.py\"\n        file_content #\"\ndef process_file(filepath):\n    print(f\"Processing {filepath}\")\n    \n    with open(filepath, 'r') as f:\n        data = f.read()\n    \n    print(\"File read successfully\")\n    \n    result = transform(data)\n    print(f\"Transformation complete: {len(result)} bytes\")\n    \n    return result\n\ndef transform(data):\n    return data.upper()\n\"#\n      }\n    ]\n    codebase_context {\n      file_tree #\"\nsrc/\n├── processor.py\n└── config.py\n\"#\n      related_files []\n      project_language \"python\"\n      project_framework null\n    }\n    conversation_history []\n  }\n}\n\n// Test 5: With conversation history\ntest TestWithConversationContext {\n  functions [Coder]\n  args {\n    user_message \"Now also update the email validation to check for the domain\"\n    files [\n      {\n        file_path \"src/validators.py\"\n        file_content #\"\nimport re\n\ndef validate_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\ndef validate_phone(phone):\n    return len(phone) >= 10\n\"#\n      }\n    ]\n    codebase_context null\n    conversation_history [\n      {\n        role \"user\"\n        content \"Can you improve the email validation function?\"\n      },\n      {\n        role \"assistant\"\n        content \"I've added regex pattern validation to check email format properly.\"\n      }\n    ]\n  }\n}\n\n// Test 6: Complex indentation preservation\ntest TestIndentationPreservation {\n  functions [Coder]\n  args {\n    user_message \"Add a check to ensure the user is authenticated before processing\"\n    files [\n      {\n        file_path \"src/api/routes.js\"\n        file_content #\"\nconst express = require('express');\nconst router = express.Router();\n\nrouter.post('/submit', async (req, res) => {\n    try {\n        const data = req.body;\n        const result = await processData(data);\n        res.json({ success: true, result });\n    } catch (error) {\n        res.status(500).json({ error: error.message });\n    }\n});\n\nmodule.exports = router;\n\"#\n      }\n    ]\n    codebase_context {\n      file_tree #\"\nsrc/\n├── api/\n│   ├── routes.js\n│   └── middleware.js\n└── utils/\n    └── auth.js\n\"#\n      related_files [\n        {\n          file_path \"src/api/middleware.js\"\n          relationship \"uses\"\n          relevant_excerpt #\"\nfunction requireAuth(req, res, next) {\n  if (!req.user) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  next();\n}\n\"#\n        }\n      ]\n      project_language \"javascript\"\n      project_framework \"Express\"\n    }\n    conversation_history []\n  }\n}\n\n// Test 7: Edge case - empty file or minimal change\ntest TestMinimalChange {\n  functions [Coder]\n  args {\n    user_message \"Change the constant value from 100 to 200\"\n    files [\n      {\n        file_path \"src/config.py\"\n        file_content #\"\nMAX_RETRIES = 100\nTIMEOUT = 30\n\"#\n      }\n    ]\n    codebase_context null\n    conversation_history []\n  }\n}\n\n// Test 8: Type system changes affecting multiple files\ntest TestTypeSystemChange {\n  functions [Coder]\n  args {\n    user_message \"Change the User interface to make email optional and add a phone number field\"\n    files [\n      {\n        file_path \"src/types/user.ts\"\n        file_content #\"\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n  createdAt: Date;\n}\n\nexport interface UserCreateRequest {\n  name: string;\n  email: string;\n}\n\"#\n      }\n    ]\n    codebase_context {\n      file_tree #\"\nsrc/\n├── types/\n│   └── user.ts\n├── services/\n│   └── userService.ts\n└── components/\n    └── UserForm.tsx\n\"#\n      related_files [\n        {\n          file_path \"src/services/userService.ts\"\n          relationship \"uses\"\n          relevant_excerpt #\"\nimport { User, UserCreateRequest } from '../types/user';\n\nexport function createUser(data: UserCreateRequest): User {\n  // implementation\n}\n\"#\n        },\n        {\n          file_path \"src/components/UserForm.tsx\"\n          relationship \"uses\"\n          relevant_excerpt #\"\nimport { UserCreateRequest } from '../types/user';\n\nfunction UserForm() {\n  const [email, setEmail] = useState('');\n  // ...\n}\n\"#\n        }\n      ]\n      project_language \"typescript\"\n      project_framework \"React\"\n    }\n    conversation_history []\n  }\n}\n",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.214.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "pdf_parser.baml": "class ContentBlock {\n    id string\n    type string // \"text\" | \"table\" | \"image\" | \"list\" | \"heading\"\n    content string\n    structured_data map<string, string>?\n    semantic_tags string[]\n    context string\n    page_number int\n    position int\n}\n\nclass PageMetadata {\n    page_number int\n    has_continuation_from_previous bool // Does content continue from previous page?\n    continues_to_next bool // Does content continue to next page?\n    section_name string? // Current section/chapter name if identifiable\n}\n\nclass PDFPageDocument {\n    page_summary string\n    content_blocks ContentBlock[]\n    key_entities map<string, string[]>?\n    metadata PageMetadata\n}\n\nfunction PdfParser(pdf_input: pdf, page_number: int, previous_page_context: string?) -> PDFPageDocument {\n    client GeminiGeneral\n    prompt #\"\n    You are parsing a PDF page-by-page. This is PAGE {{ page_number }}.\n\n    {% if previous_page_context %}\n    CONTEXT FROM PREVIOUS PAGE:\n    {{ previous_page_context }}\n    \n    Important: Check if any content on this page is a continuation from the previous page.\n    {% endif %}\n\n    Your task: Extract and structure this single page into intelligent, queryable blocks.\n\n    ## STEP 1: Analyze Page Context\n    - What section/chapter is this page part of? (look for headers, footers, section titles)\n    - Does content start mid-sentence or mid-paragraph? (continuation from previous page)\n    - Does content end incomplete? (continues to next page)\n    - What's the primary topic/purpose of THIS page?\n\n    ## STEP 2: Extract Content Blocks\n    Create a ContentBlock for each distinct piece of content:\n\n    **ID Format**: \"p{{ page_number }}_block_N\" or \"p{{ page_number }}_table_N\" or \"p{{ page_number }}_image_N\"\n    \n    **Type Classification**:\n    - \"heading\": Titles, section headers (include heading level in structured_data)\n    - \"text\": Paragraphs, body content\n    - \"table\": Tabular data\n    - \"list\": Bullet points or numbered lists\n    - \"image\": Charts, diagrams, photos\n\n    **Content**: \n    - For text/lists: Full markdown content\n    - For tables: Markdown table + structured JSON in structured_data\n    - For images: Detailed description including what it shows and its purpose\n\n    **Structured Data** (when applicable):\n    - Tables: {{\"{\"}} \"headers\": [...], \"rows\": [[...]], \"caption\": \"...\" {{\"}\"}}\n    - Headings: {{\"{\"}} \"level\": 1-6, \"is_section_start\": true/false {{\"}\"}}\n    - Lists: {{\"{\"}} \"list_type\": \"bullet\"|\"numbered\", \"items\": [...] {{\"}\"}}\n\n    **Semantic Tags** (critical for retrieval):\n    Think: \"What would someone search for to find this content?\"\n    Examples:\n    - [\"executive_summary\", \"key_findings\"]\n    - [\"financial_results\", \"Q4_2024\", \"revenue\"]\n    - [\"methodology\", \"technical\", \"data_collection\"]\n    - [\"pricing\", \"product_features\"]\n    - [\"conclusion\", \"recommendations\"]\n    - [\"introduction\", \"background\"]\n    \n    Be specific AND broad: [\"sales_data\", \"financial\", \"2024\"]\n\n    **Context** (help future retrieval understand this block):\n    Describe WHERE and WHY this appears. Examples:\n    - \"Opening paragraph of the 'Market Analysis' section\"\n    - \"Summary table showing quarterly revenue breakdown\"\n    - \"Chart illustrating customer growth trends, referenced in conclusion\"\n    - \"Continuation of methodology discussion from previous page\"\n\n    **Position**: Number blocks sequentially as they appear (1, 2, 3...)\n\n    ## STEP 3: Extract Key Entities (from this page only)\n    Look for:\n    - **people**: Names of individuals mentioned\n    - **organizations**: Companies, institutions\n    - **dates**: Specific dates or time periods\n    - **locations**: Places, regions, countries\n    - **metrics**: Important numbers with context (e.g., \"$1.2M revenue\", \"45% growth\")\n    - **products**: Product or service names\n\n    ## STEP 4: Page Metadata\n    - **page_number**: {{ page_number }}\n    - **has_continuation_from_previous**: Does this page continue content from previous page?\n    - **continues_to_next**: Does content end incomplete (likely continues next page)?\n    - **section_name**: What section/chapter is this page in?\n\n    ## STEP 5: Page Summary\n    Write 2-3 sentences summarizing ONLY this page's content. Focus on:\n    - Main topics covered\n    - Key information presented\n    - How it fits in the document flow\n\n    ---\n\n    CRITICAL RULES:\n    1. **Completeness**: Extract ALL visible content - don't skip anything\n    2. **Accuracy**: Transcribe text exactly, preserve table data precisely\n    3. **Context awareness**: Note if content is continued from/to other pages\n    4. **Semantic richness**: Add multiple relevant tags per block\n    5. **Traceability**: Every block must have page_number = {{ page_number }}\n\n    PDF Page {{ page_number }}:\n    {{ pdf_input }}\n\n    Output a complete PDFPageDocument with rich metadata for this single page.\n  \"#\n}",
    "prompt_engineering.baml": "",
    "researcher.baml": "",
    "second_brain.baml": "",
    "writer.baml": "",
}

def get_baml_files():
    return _file_map